#!/usr/bin/env python3
import numpy as np
import transformation
import mapping
import cv2
import skfmm
import numpy.ma as npmask
import lcmutils
from lcm_types.pose_t import pose_t
from lcm_types.pointcloud_t import pointcloud_t
from lcm_types.image_t import image_t
import threading
import json
import optparse

def barrier_force(distance):
    return -10 * distance

def goal_force(distance):
    return distance

def compute_force(potential_map, scale, ij):
    ij = ij.reshape(-1)
    ij_min = None
    potential_min = np.inf
    for di in range(-1, 0, +1):
        i = ij[0] + di
        if i >= 0 and i < potential_map.shape[0]:
            for dj in range(-1, 0, +1):
                j = ij[1] + di
                if j >= 0 and j < potential_map.shape[1]:
                    if potential_map[i, j] < potential_min:
                        ij_min = np.array([i, j])
                        potential_min = potential_map[i, j]
    delta = (ij_min - ij) / (scale * np.linalg.norm(ij_min - ij) ** 2)
    return (potential_map[i, j] - potential_min) * delta

def potential_dynamics(inertia, damping, dt, velocity, force):
    return velocity + (dt / inertia) * (force - damping * velocity)

if __name__ == "__main__":
    # Parse command-line arguments
    parser = optparse.OptionParser()

    parser.add_option("-u", "--url", dest="url", help="Publish packets to LCMURL", metavar="LCMURL", default=None)
    parser.add_option("-c", "--config", dest="config", help="Read camera config from CONFIGFILE", metavar="CONFIGFILE")
    parser.add_option("-p", "--pose", dest="pose", help="Read pose from POSECHANNEL", metavar="POSECHANNEL", default="REALSENSE_POSE")
    parser.add_option("-t", "--pointcloud", dest="pointcloud", help="Read pointcloud from POINTCLOUDCHANNEL", metavar="POINTCLOUDCHANNEL", default="REALSENSE_POINTCLOUD")
    parser.add_option("-m", "--map", dest="map", help="Publish map to MAPCHANNEL", metavar="MAPCHANNEL", default="INTEGRATED_MAP")
    parser.add_option("-v", "--visualize", dest="visualize", help="Show a visualization of integrated map", action="store_true")

    (options, args) = parser.parse_args()

    # Initialize the LCM node
    node = lcmutils.node(options.url)

    # Load the config file to read camera parameters, etc.
    with open(options.config) as f:
        config = json.load(f)

    # Construct an empty lattice to hold the occupancy grid of the environment
    delta = 0.02
    basis = delta * np.array([[1, 0, 0], [0, 1, 0]])
    normal = np.array([[0, 0, 1]])
    origin = np.array([-5, -5, 0])
    subspace = mapping.Subspace.from_components(basis, normal, origin)
    arr = np.zeros((int(10 / delta), int(10 / delta)), dtype="uint8")
    lattice = mapping.Lattice(arr, subspace)

    # Create a goal map to store where the goal point is
    goal_map = np.ones_like(arr, dtype="float")

    # Store the current pose for visualization purposes
    pose = None

    # If visualization is turned on, enable clicking on the image to change where the goal
    # point is
    if options.visualize:
        def grid_click(event, x, y, flags, param):
            if event == cv2.EVENT_LBUTTONUP:
                i = y
                j = x - lattice.arr.shape[0]
                goal_map[:] = 1
                goal_map[i,j] = 0
        cv2.namedWindow("grid")
        cv2.setMouseCallback("grid", grid_click)

    # Handle incoming pointclouds and pose over LCM by updating the occupancy grid with
    # the new points
    def input_handler(msg_pointcloud, msg_pose):
        global pose
        pose_array = np.array(msg_pose.orientation + msg_pose.position)
        pose = transformation.from_array(pose_array)
        points = np.array(msg_pointcloud.points).reshape(int(msg_pointcloud.n / 3), 3)
        points = pose * points
        camera = pose.t
        principal = pose * np.array([[1, 0, 0]]) - camera
        mapping.update_occupancy_grid(lattice, points) #, camera, principal, config["fx"])
    
    # Recompute potential function and show visualization of the environment
    running = True
    def planner():
        global running
        while running:
            if pose is not None:
                # Compute the potential function for a given goal
                try:
                    mask = lattice.arr.astype("bool")
                    scene = npmask.array(goal_map, mask=mask)
                    goal_potential = goal_force(skfmm.distance(scene))
                    barrier_potential = barrier_force(skfmm.distance(lattice.arr.astype("float")))
                    potential_map = goal_potential + barrier_potential
                except ValueError:
                    potential_map = None
                
                # If visualization is turned on, show the occupancy grid, potential
                # function, and current position and orientation of the robot
                if options.visualize:
                    if potential_map is None:
                        img = 255 * lattice.arr
                    else:
                        img = (255 / (potential_map.max() - potential_map.min()) * (potential_map.astype("float") - potential_map.min())).astype("uint8")
                    camera, _ = lattice.project(pose * np.array([[0, 0, 0], [1, 0, 0]]))
                    camera[1] = camera[0] + 15 * (camera[1] - camera[0]) / np.linalg.norm(camera[1] - camera[0])
                    camera_origin = tuple(camera[0,::-1].astype("int"))
                    camera_end = tuple(camera[1,::-1].astype("int"))
                    cv2.arrowedLine(img, camera_origin, camera_end, 255, 1)
                    cv2.imshow("grid", img)
                    if cv2.waitKey(1) == ord("q"):
                        running = False
    
    # Subscribe to the pointcloud and pose channels in a synchronized way (handled by
    # "input_handler")
    lcmutils.subscribe_sync_exact(node, [options.pointcloud, options.pose],
        [pointcloud_t, pose_t], input_handler, verbose=True)
    
    # Run the planner thread (handled by "planner")
    planner_thread = threading.Thread(target=planner)
    planner_thread.setDaemon(True)
    planner_thread.start()

    # Run the LCM node to constantly handle new incoming messages
    while running:
        node.handle()

